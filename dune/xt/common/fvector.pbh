// This file is part of the dune-xt-common project:
//   https://github.com/dune-community/dune-xt-common
// The copyright lies with the authors of this file (see below).
// License: Dual licensed as  BSD 2-Clause License (http://opensource.org/licenses/BSD-2-Clause)
//      or  GPL-2.0+ (http://opensource.org/licenses/gpl-license)
//          with "runtime exception" (http://www.dune-project.org/license.html)
// Authors:
//   Felix Schindler (2016)

#ifndef DUNE_XT_COMMON_FVECTOR_PBH
#define DUNE_XT_COMMON_FVECTOR_PBH
#if HAVE_DUNE_PYBINDXI

#include <sstream>

#include <dune/pybindxi/pybind11.h>
#include <dune/pybindxi/cast.h>
#include <dune/pybindxi/operators.h>

#include "string.hh"
#include "fvector.hh"


namespace Dune {
namespace XT {
namespace Common {
namespace internal {


template <class C, class T>
void addbind_FieldVector_ctor_from_iterable(T& c)
{
  namespace py = pybind11;

  c.def("__init__",
        [](C& vec, py::iterable it) {
          new (&vec) C(0);
          try {
            size_t ii = 0;
            for (py::handle h : it) {
              if (ii >= vec.size())
                throw pybind11::index_error(Common::to_string(ii));
              vec[ii++] = h.cast<typename C::value_type>();
            }
          } catch (...) {
            vec.~C();
            throw;
          }
        },
        "Assigns the elements of the iterable to the first elements of the vector and fills the rest with 0. "
        "Throws an error if the iterable has too many elements");
} // ... addbind_FieldVector_ctor_from_iterable(...)


} // namespace internal


template <class K, int SIZE>
pybind11::class_<Dune::XT::Common::FieldVector<K, SIZE>> bind_FieldVector(pybind11::module& m, const std::string& K_str)
{
  namespace py = pybind11;
  using namespace pybind11::literals;

  typedef Dune::FieldVector<K, SIZE> C;

  py::class_<C> c(m,
                  std::string("FieldVector_" + K_str + "_" + to_string(SIZE)).c_str(),
                  std::string("FieldVector_" + K_str + "_" + to_string(SIZE)).c_str());

  c.def(py::init<K>(), "value"_a = 0, "Assigns all elements of the vector with the given value.");
  internal::addbind_FieldVector_ctor_from_iterable<C>(c);

  c.def("__repr__", [K_str](const C& self) {
    return "FieldVector_" + K_str + "_" + to_string(SIZE) + "(" + to_string(self) + ")";
  });
  c.def("__len__", [](const C& /*self*/) { return SIZE; });
  c.def("__getitem__", [](const C& vec, size_t ii) -> K {
    if (ii >= vec.size())
      throw pybind11::index_error();
    return vec[ii];
  });
  c.def("__setitem__", [](C& vec, size_t ii, const K& value) {
    if (ii >= vec.size())
      throw pybind11::index_error();
    vec[ii] = value;
  });
  c.def("__iter__",
        [](C& vec) {
          return py::
              make_iterator<py::return_value_policy::reference_internal, typename C::iterator, typename C::iterator, K>(
                  vec.begin(), vec.end());
        },
        pybind11::keep_alive<0, 1>() /*Essential: keep object alive while iterator exists!*/);

  c.def(py::self == py::self);
  c.def(py::self != py::self);
  c.def(py::self + py::self);
  c.def(py::self += py::self);
  c.def(py::self - py::self);
  c.def(py::self -= py::self);
  c.def(py::self * py::self);
  //  c.def(py::self * K()); // <- not possible for FieldVector
  c.def(py::self *= K());
  c.def(py::self /= K());

  c.def("assign_from", [](C& self, const C& other) { self = other; }, "other"_a);
  c.def("size", &C::size);
  c.def("axpy", [](C& self, const K& a, const C& y) { self.axpy(a, y); }, "a"_a, "y"_a);
  c.def("dot", [](C& self, const C& y) { self.dot(y); }, "y"_a);
  c.def("one_norm", [](const C& self) { return self.one_norm(); });
  c.def("two_norm", &C::two_norm);
  c.def("two_norm2", &C::two_norm2);
  c.def("infinity_norm", &C::infinity_norm);

  return c;
} // bind_FieldVector


template <class K, int SIZE>
pybind11::class_<Dune::XT::Common::FieldVector<K, SIZE>> bind_XtCommonFieldVector(pybind11::module& m,
                                                                                  const std::string& K_str)
{
  namespace py = pybind11;
  using namespace pybind11::literals;

  typedef Dune::XT::Common::FieldVector<K, SIZE> C;

  py::class_<C, Dune::FieldVector<K, SIZE>> c(m,
                                              std::string("FieldVectorXT_" + K_str + "_" + to_string(SIZE)).c_str(),
                                              std::string("FieldVectorXT_" + K_str + "_" + to_string(SIZE)).c_str());

  c.def(py::init<K>(), "value"_a = 0, "Assigns all elements of the vector with the given value.");
  internal::addbind_FieldVector_ctor_from_iterable<C>(c);

  c.def(py::self * K());

  return c;
} // bind_XtCommonFieldVector


} // namespace Common
} // namespace XT
} // namespace Dune
NAMESPACE_BEGIN(pybind11)
NAMESPACE_BEGIN(detail)


template <class Type>
struct FieldVector_type_caster
{
  typedef typename Type::value_type K;
  using type = Type;
  using value_conv = make_caster<K>;

  bool load(handle src, bool convert)
  {
    sequence s(src, true);
    if (!s.check())
      return false;
    value_conv conv;
    value *= K(0.0);
    size_t ii = 0;
    for (auto it : s) {
      if (ii >= value.size())
        return false;
      if (!conv.load(it, convert))
        return false;
      value[ii++] = K(conv);
    }
    return true;
  } // ... load(...)

  static handle cast(const Type& src, return_value_policy policy, handle parent)
  {
    list l(src.size());
    for (size_t ii = 0; ii < src.size(); ++ii) {
      object val = object(value_conv::cast(src[ii], policy, parent), false);
      if (!val)
        return handle();
      PyList_SET_ITEM(l.ptr(), ii, val.release().ptr()); // steals a reference
    }
    return l.release();
  } // ... cast(...)

  PYBIND11_TYPE_CASTER(Type, _("List[") + value_conv::name() + _("]"));
}; // struct FieldVector_type_caster


template <class K, int SIZE>
struct type_caster<Dune::FieldVector<K, SIZE>> : public FieldVector_type_caster<Dune::FieldVector<K, SIZE>>
{
};

template <class K, int SIZE>
struct type_caster<Dune::XT::Common::FieldVector<K, SIZE>>
    : public FieldVector_type_caster<Dune::XT::Common::FieldVector<K, SIZE>>
{
};


NAMESPACE_END(detail)
NAMESPACE_END(pybind11)

#endif // HAVE_DUNE_PYBINDXI
#endif // DUNE_XT_COMMON_FVECTOR_PBH
