// This file is part of the dune-xt-la project:
//   https://github.com/dune-community/dune-xt-la
// The copyright lies with the authors of this file (see below).
// License: Dual licensed as  BSD 2-Clause License (http://opensource.org/licenses/BSD-2-Clause)
//      or  GPL-2.0+ (http://opensource.org/licenses/gpl-license)
//          with "runtime exception" (http://www.dune-project.org/license.html)
// Authors:
//   Felix Schindler (2016)

#ifndef DUNE_XT_LA_CONTAINER_INTERFACE_PBH
#define DUNE_XT_LA_CONTAINER_INTERFACE_PBH
#if HAVE_DUNE_PYBINDXI

#include <dune/pybindxi/pybind11.h>
#include <dune/pybindxi/operators.h>

#include <dune/xt/la/type_traits.hh>

#include "container-interface.hh"

namespace Dune {
namespace XT {
namespace LA {


pybind11::enum_<Backends> bind_Backends(pybind11::module& m)
{
  namespace py = pybind11;

  py::enum_<Backends> c(m, "Backends");
  c.value("common_dense", Backends::common_dense);
  c.value("common_sparse", Backends::common_sparse);
  c.value("istl_sparse", Backends::istl_sparse);
  c.value("eigen_dense", Backends::eigen_dense);
  c.value("eigen_sparse", Backends::eigen_sparse);
  c.value("none", Backends::none);

  m.attr("default_backend") = py::cast(default_backend);
  m.attr("default_sparse_backend") = py::cast(default_sparse_backend);
  m.attr("default_dense_backend") = py::cast(default_dense_backend);

  return c;
} // ... bind_Backends(...)


template <class C>
typename std::enable_if<is_container<C>::value, void>::type addbind_ContainerInterface(pybind11::class_<C>& c)
{
  namespace py = pybind11;
  using namespace pybind11::literals;

  typedef typename C::ScalarType S;

  c.def("copy", &C::copy);
  c.def("scal", &C::scal);
  c.def("axpy", [](C& self, const S& alpha, const C& xx) { self.axpy(alpha, xx); });
  c.def("has_equal_shape", &C::has_equal_shape);
  c.def(py::self *= S());
} // ... addbind_ContainerInterface(...)


template <class C>
typename std::enable_if<provides_backend<C>::value, void>::type addbind_ProvidesBackend(pybind11::class_<C>& c)
{
  c.def_property_readonly("backend_type", [](const C& /*self*/) { return C::backend_type; });
}

template <class C>
typename std::enable_if<!provides_backend<C>::value, void>::type addbind_ProvidesBackend(pybind11::class_<C>& /*c*/)
{
}


/**
 * \brief Allows the resulting container to be convertible into a NumPy array as in `np.array(c, copy = False)`.
 */
template <class C>
typename std::enable_if<provides_data_access<C>::value, void>::type addbind_ProvidesDataAccess(pybind11::class_<C>& c)
{
  namespace py = pybind11;
  typedef typename C::DataType D;

  c.def_buffer([](C& vec) -> py::buffer_info {
    return py::buffer_info(
        vec.data(), sizeof(D), py::format_descriptor<D>::format(), 1, {vec.data_size()}, {sizeof(D)});
  });
} // ... addbind_ProvidesDataAccess(...)

template <class C>
typename std::enable_if<!provides_data_access<C>::value, void>::type
addbind_ProvidesDataAccess(pybind11::class_<C>& /*c*/)
{
}


} // namespace LA
} // namespace XT
} // namespace Dune

#endif // HAVE_DUNE_PYBINDXI
#endif // DUNE_XT_LA_CONTAINER_INTERFACE_PBH
