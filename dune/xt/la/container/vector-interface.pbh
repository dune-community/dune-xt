// This file is part of the dune-xt-la project:
//   https://github.com/dune-community/dune-xt-la
// Copyright 2009-2018 dune-xt-la developers and contributors. All rights reserved.
// License: Dual licensed as BSD 2-Clause License (http://opensource.org/licenses/BSD-2-Clause)
//      or  GPL-2.0+ (http://opensource.org/licenses/gpl-license)
//          with "runtime exception" (http://www.dune-project.org/license.html)
// Authors:
//   Felix Schindler (2016 - 2017)
//   Rene Milk       (2018)

#ifndef DUNE_XT_LA_CONTAINER_VECTOR_INTERFACE_PBH
#define DUNE_XT_LA_CONTAINER_VECTOR_INTERFACE_PBH
#if HAVE_DUNE_PYBINDXI

#include <sstream>

#include <dune/pybindxi/pybind11.h>
#include <dune/pybindxi/operators.h>

#include <dune/xt/common/numeric_cast.hh>
#include <dune/xt/common/string.hh>

#include <dune/xt/la/type_traits.hh>
#include <dune/xt/la/container.bindings.hh>

#include "io.hh"
#include "vector-interface.hh"
#include "container-interface.pbh"


namespace Dune {
namespace XT {
namespace LA {


template <class C>
typename std::enable_if<is_vector<C>::value, pybind11::class_<C>>::type bind_Vector(pybind11::module& m)
{
  namespace py = pybind11;
  using namespace pybind11::literals;

  typedef typename C::ScalarType S;
  typedef typename C::RealType R;

  const auto ClassName = Common::to_camel_case(bindings::container_name<C>::value());

  py::class_<C> c = bind_ProvidesDataAccess<C>(m, ClassName, ClassName);
  addbind_ProvidesBackend(c);

  c.def("__init__",
        [](C& vec, const ssize_t size, const S& value) { new (&vec) C(Common::numeric_cast<size_t>(size), value); },
        "size"_a = 0,
        "value"_a = 0.0);
  c.def("__init__",
        [](C& vec, py::iterable it) {
          std::vector<S> tmp;
          try {
            for (py::handle h : it)
              tmp.push_back(h.cast<S>());
            new (&vec) C(tmp);
          } catch (...) {
            vec.~C();
            throw;
          }
        },
        "Assigns the elements of the iterable to the vector.");

  c.def("__repr__",
        [ClassName](const C& self) {
          std::stringstream ss;
          ss << ClassName << "([";
          if (self.size() > 0)
            ss << self[0];
          for (size_t ii = 1; ii < std::min(size_t(3), self.size()); ++ii)
            ss << " " << self[ii];
          if (self.size() > 8) {
            ss << " ...";
          } else {
            for (ssize_t ii = std::min(size_t(3), self.size()); ii < ssize_t(self.size()) - 3; ++ii)
              ss << " " << self[ii];
          }
          for (size_t ii = std::max(ssize_t(3), ssize_t(self.size()) - 3); ii < self.size(); ++ii)
            ss << " " << self[ii];
          ss << "])";
          return ss.str();
        },
        "A compact representation of the vector (only the first and last three elements).");
  c.def("__str__",
        [ClassName](const C& self) {
          std::stringstream ss;
          ss << ClassName << "([";
          if (self.size() > 0)
            ss << self[0];
          for (size_t ii = 1; ii < self.size(); ++ii)
            ss << " " << self[ii];
          ss << "])";
          return ss.str();
        },
        "A full representation of the vector.");
  c.def("__len__", [](const C& self) { return self.size(); });
  c.def("__getitem__", [](const C& vec, size_t ii) -> S {
    if (ii >= vec.size())
      throw pybind11::index_error();
    return vec[ii];
  });
  c.def("__setitem__", [](C& vec, size_t ii, const S& value) {
    if (ii >= vec.size())
      throw pybind11::index_error();
    vec[ii] = value;
  });
  c.def("__iter__",
        [](C& vec) {
          return py::
              make_iterator<py::return_value_policy::reference_internal, typename C::iterator, typename C::iterator, S>(
                  vec.begin(), vec.end());
        },
        pybind11::keep_alive<0, 1>() /*Essential: keep object alive while iterator exists!*/);

  c.def(py::self == py::self);
  c.def(py::self != py::self);
  c.def(py::self + py::self);
  c.def(py::self += py::self);
  c.def(py::self -= py::self);
  c.def(py::self * py::self);
  c.def(py::self *= R());
  c.def(py::self /= R());

  c.def_property_readonly("size", [](const C& self) { return self.size(); });
  c.def("add_to_entry",
        [](C& self, const ssize_t ii, const S& value) { self.add_to_entry(Common::numeric_cast<size_t>(ii), value); },
        "ii"_a,
        "value"_a);
  c.def("set_entry",
        [](C& self, const ssize_t ii, const S& value) { self.set_entry(Common::numeric_cast<size_t>(ii), value); },
        "ii"_a,
        "value"_a);
  c.def("get_entry",
        [](const C& self, const ssize_t ii) { return self.get_entry(Common::numeric_cast<size_t>(ii)); },
        "jj"_a);
  c.def("set_all", [](C& self, const S& value) { self.set_all(value); }, "value"_a);
  c.def("valid", [](const C& self) { return self.valid(); });
  c.def("dim", [](const C& self) { return self.dim(); });
  c.def("mean", [](const C& self) { return self.mean(); });
  c.def("amax", [](const C& self) { return self.amax(); });
  c.def("almost_equal",
        [](const C& self, const C& other, const S& epsilon) { return self.almost_equal(other, epsilon); },
        "other"_a,
        "epsilon"_a = Common::FloatCmp::DefaultEpsilon<S>::value());
  c.def("dot", [](const C& self, const C& other) { return self.dot(other); });
  c.def("l1_norm", [](const C& self) { return self.l1_norm(); });
  c.def("l2_norm", [](const C& self) { return self.l2_norm(); });
  c.def("sup_norm", [](const C& self) { return self.sup_norm(); });
  c.def("standard_deviation", [](const C& self) { return self.standard_deviation(); });
  c.def("to_file",
        [](const C& self, const std::string& filename, const std::string& mode) { to_file(self, filename, mode); },
        "filename"_a,
        "mode"_a = "ascii");
  c.def_static("from_file",
               [](const std::string& filename, const ssize_t min_size, const std::string& mode) {
                 return from_file<C>(filename, min_size, mode);
               },
               "filename"_a,
               "min_size"_a = -1,
               "mode"_a = "ascii");

  c.def("__getstate__", [](const C& self) { return py::make_tuple(std::vector<S>(self)); });
  c.def("__setstate__", [](C& self, py::tuple t) {
    if (t.size() != 1)
      throw std::runtime_error("Invalid state!");
    auto data = t[0].cast<std::vector<S>>();
    /* Invoke the in-place constructor. Note that this is needed even
    when the object just has a trivial default constructor */
    new (&self) C(data.size());
    /* Assign any additional state */
    for (size_t ii = 0; ii < self.size(); ++ii)
      self[ii] = data[ii];
  });

  addbind_ContainerInterface(c);

  return c;
} // ... bind_Vector(...)


} // namespace LA
} // namespace XT
} // namespace Dune

#endif // HAVE_DUNE_PYBINDXI
#endif // DUNE_XT_LA_CONTAINER_VECTOR_INTERFACE_PBH
