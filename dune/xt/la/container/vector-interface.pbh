// This file is part of the dune-xt-la project:
//   https://github.com/dune-community/dune-xt-la
// The copyright lies with the authors of this file (see below).
// License: Dual licensed as  BSD 2-Clause License (http://opensource.org/licenses/BSD-2-Clause)
//      or  GPL-2.0+ (http://opensource.org/licenses/gpl-license)
//          with "runtime exception" (http://www.dune-project.org/license.html)
// Authors:
//   Felix Schindler (2016)

#ifndef DUNE_XT_LA_CONTAINER_VECTOR_INTERFACE_PBH
#define DUNE_XT_LA_CONTAINER_VECTOR_INTERFACE_PBH
#if HAVE_DUNE_PYBINDXI

#include <sstream>

#include <boost/numeric/conversion/cast.hpp>

#include <dune/pybindxi/pybind11.h>
#include <dune/pybindxi/operators.h>

#include <dune/xt/common/string.hh>

#include <dune/xt/la/type_traits.hh>

#include "vector-interface.hh"
#include "container-interface.pbh"

namespace Dune {
namespace XT {
namespace LA {


template <class C>
typename std::enable_if<is_vector<C>::value, pybind11::class_<C>>::type bind_Vector(pybind11::module& m,
                                                                                    const std::string& id)
{
  namespace py = pybind11;
  using namespace pybind11::literals;

  typedef typename C::ScalarType S;
  typedef typename C::RealType R;

  py::class_<C> c = bind_ProvidesDataAccess<C>(m, id, id);
  addbind_ProvidesBackend(c);

  c.def_property_readonly_static("dense_matrix_type", [](py::object /*self*/) { return C::dense_matrix_type; });
  c.def_property_readonly_static("sparse_matrix_type", [](py::object /*self*/) { return C::sparse_matrix_type; });

  c.def("__init__",
        [](C& vec, const ssize_t size, const S& value) {
          try {
            new (&vec) C(boost::numeric_cast<size_t>(size), value);
          } catch (boost::bad_numeric_cast& ee) {
            DUNE_THROW(Common::Exceptions::wrong_input_given,
                       "Given size has to be positive!\n\n The error in boost while converting '"
                           << size
                           << "' to '"
                           << Common::Typename<size_t>::value()
                           << "' was: "
                           << ee.what());
          }
        },
        "size"_a = 0,
        "value"_a = 0.0);
  c.def("__init__",
        [](C& vec, py::iterable it) {
          std::vector<S> tmp;
          try {
            for (py::handle h : it)
              tmp.push_back(h.cast<S>());
            new (&vec) C(tmp);
          } catch (...) {
            vec.~C();
            throw;
          }
        },
        "Assigns the elements of the iterable to the vector.");

  c.def("__repr__",
        [id](const C& self) {
          std::stringstream ss;
          ss << id << "([";
          if (self.size() > 0)
            ss << self[0];
          for (size_t ii = 1; ii < std::min(size_t(3), self.size()); ++ii)
            ss << " " << self[ii];
          if (self.size() > 8) {
            ss << " ...";
          } else {
            for (ssize_t ii = std::min(size_t(3), self.size()); ii < ssize_t(self.size()) - 3; ++ii)
              ss << " " << self[ii];
          }
          for (size_t ii = std::max(ssize_t(3), ssize_t(self.size()) - 3); ii < self.size(); ++ii)
            ss << " " << self[ii];
          ss << "])";
          return ss.str();
        },
        "A compact representation of the vector (only the first and last three elements).");
  c.def("__str__",
        [id](const C& self) {
          std::stringstream ss;
          ss << id << "([";
          if (self.size() > 0)
            ss << self[0];
          for (size_t ii = 1; ii < self.size(); ++ii)
            ss << " " << self[ii];
          ss << "])";
          return ss.str();
        },
        "A full representation of the vector.");
  c.def("__len__", [](const C& self) { return self.size(); });
  c.def("__getitem__", [](const C& vec, size_t ii) -> S {
    if (ii >= vec.size())
      throw pybind11::index_error();
    return vec[ii];
  });
  c.def("__setitem__", [](C& vec, size_t ii, const S& value) {
    if (ii >= vec.size())
      throw pybind11::index_error();
    vec[ii] = value;
  });
  c.def("__iter__",
        [](C& vec) {
          return py::
              make_iterator<py::return_value_policy::reference_internal, typename C::iterator, typename C::iterator, S>(
                  vec.begin(), vec.end());
        },
        pybind11::keep_alive<0, 1>() /*Essential: keep object alive while iterator exists!*/);

  c.def(py::self == py::self);
  c.def(py::self != py::self);
  c.def(py::self + py::self);
  c.def(py::self += py::self);
  c.def(py::self - py::self);
  c.def(py::self -= py::self);
  c.def(py::self * py::self);
  c.def(py::self * R());
  c.def(py::self *= R());
  c.def(py::self /= R());

  c.def("size", &C::size);
  c.def("add_to_entry", &C::add_to_entry, "ii"_a, "value"_a);
  c.def("set_entry", &C::set_entry, "ii"_a, "value"_a);
  c.def("get_entry", &C::get_entry);
  c.def("set_all", &C::set_all);
  c.def("valid", &C::valid);
  c.def("dim", &C::dim);
  c.def("mean", &C::mean);
  c.def("amax", &C::amax);
  c.def("almost_equal",
        [](const C& self, const C& other, const S& epsilon) { return self.almost_equal(other, epsilon); },
        "other"_a,
        "epsilon"_a = Common::FloatCmp::DefaultEpsilon<S>::value());
  c.def("dot", [](const C& self, const C& other) { return self.dot(other); });
  c.def("l1_norm", &C::l1_norm);
  c.def("l2_norm", &C::l2_norm);
  c.def("sup_norm", &C::sup_norm);
  c.def("standard_deviation", &C::standard_deviation);

  addbind_ContainerInterface(c);

  return c;
} // ... bind_Vector(...)


} // namespace LA
} // namespace XT
} // namespace Dune

#endif // HAVE_DUNE_PYBINDXI
#endif // DUNE_XT_LA_CONTAINER_VECTOR_INTERFACE_PBH
